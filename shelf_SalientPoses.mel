global proc shelf_SalientPoses () {
    global string $gBuffStr;
    global string $gBuffStr0;
    global string $gBuffStr1;


    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Open's the Salient Poses Menu" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Open Menu" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "MENU" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "import math\n\n\nfrom PySide2 import QtGui, QtCore, QtWidgets\nfrom PySide2.QtGui import QPen, QBrush, QPainter\nfrom shiboken2 import wrapInstance\n\n\nimport maya.cmds as cmds\nimport maya.mel as mel\nimport maya.OpenMayaUI as omui \nfrom maya.app.general.mayaMixin import MayaQWidgetBaseMixin, MayaQWidgetDockableMixin\n\n\n\nWINDOW_WIDTH = 400\nWINDOW_QUARTER = WINDOW_WIDTH * 0.25\nLABEL_WIDTH = WINDOW_QUARTER * 1\n\n\n\nclass Prompt:\n\n\n    @staticmethod\n    def get_file(message):\n        paths = cmds.fileDialog2(fileMode=0, caption=message)\n        if paths == None:\n            cmds.error(\"Please select a valid filepath\")\n            return None\n        elif len(paths) == 1:\n            return paths[0]\n        else:\n            cmds.error(\"Please select a valid filepath\")\n            return None\n\n\n    @staticmethod\n    def get_folder(message):\n        paths = cmds.fileDialog2(fileMode=2, caption=message)\n        if paths == None:\n            cmds.error(\"Please select a valid filepath\")\n        elif len(paths) == 1:\n            return paths[0]\n        else:\n            cmds.error(\"Please select a valid filepath\")\n            return None\n    \n    @staticmethod\n    def get_string(title, message):\n        result = cmds.promptDialog(\n                    title=title,\n                    message=message,\n                    button=['OK', 'Cancel'],\n                    defaultButton='OK',\n                    cancelButton='Cancel',\n                    dismissString='Cancel')\n\n\n        if result == 'OK':\n            return cmds.promptDialog(query=True, text=True)\n        else:\n            return None\n\n\nclass UIFonts:\n    header = QtGui.QFont(\"Arial\", 10, QtGui.QFont.Bold)\n\n\nclass UIBuilder:\n\n\n    @staticmethod\n    def vertical_box(parent=None, add_to=None):\n        vbox = QtWidgets.QVBoxLayout(parent)\n        if add_to != None: add_to.addLayout(vbox)\n        return vbox\n\n\n    @staticmethod\n    def horizontal_box(parent=None, add_to=None):\n        hbox = QtWidgets.QHBoxLayout(parent)\n        if add_to != None: add_to.addLayout(hbox)\n        return hbox\n\n\n    @staticmethod\n    def make_separator(add_to):\n        line = QtWidgets.QFrame()\n        line.setFrameShape(QtWidgets.QFrame.HLine)\n        line.setFrameShadow(QtWidgets.QFrame.Sunken)\n        add_to.addWidget(line)\n\n\n    @staticmethod\n    def make_spacer(add_to, size):\n        spacer = QtWidgets.QSpacerItem(size[0], size[1])\n        add_to.addItem(spacer)\n\n\n    @staticmethod\n    def make_spacer_1(add_to):\n        UIBuilder.make_spacer(add_to, (WINDOW_QUARTER * 1, 10))\n\n\n    @staticmethod\n    def make_spacer_2(add_to):\n        UIBuilder.make_spacer(add_to, (WINDOW_QUARTER * 2, 10))\n\n\n    @staticmethod\n    def make_spacer_3(add_to):\n        UIBuilder.make_spacer(add_to, (WINDOW_QUARTER * 3, 10))\n\n\n    @staticmethod\n    def make_spacer_4(add_to):\n        UIBuilder.make_spacer(add_to, (WINDOW_QUARTER * 4, 10))\n\n\n    @staticmethod\n    def label(add_to, text, size=-1, font=None):\n        label = QtWidgets.QLabel(text)\n        label.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        label.setMinimumWidth(LABEL_WIDTH if size == -1 else size)\n        label.setMaximumWidth(LABEL_WIDTH if size == -1 else size)\n        if font is not None: label.setFont(font)\n        add_to.addWidget(label)\n        return label\n\n\n    @staticmethod\n    def button(add_to, text, fn=None):\n        button = QtWidgets.QPushButton(text)\n        button.setMinimumWidth(WINDOW_QUARTER)\n        button.setMaximumWidth(WINDOW_QUARTER)\n        button.setText(text)\n        if fn != None: button.pressed.connect(fn)\n        add_to.addWidget(button)\n        return button\n\n\n    @staticmethod\n    def check_box(add_to, fn=None, starts=False):\n        check_box = QtWidgets.QCheckBox()\n        if starts:\n            check_box.setCheckState(QtCore.Qt.CheckState(True))\n        else:\n            check_box.setCheckState(QtCore.Qt.CheckState(False))\n\n\n        if fn != None: check_box.stateChanged.connect(fn)\n        add_to.addWidget(check_box)\n        return check_box\n\n\n    @staticmethod\n    def line_edit(add_to, text, fn=None):\n        line_edit = QtWidgets.QLineEdit()\n        line_edit.setText(text)\n        if fn != None: line_edit.returnPressed.connect(fn)\n        add_to.addWidget(line_edit)\n        return line_edit\n\n\n    @staticmethod\n    def slider(add_to, min_v, max_v, step_size, value, fn=None):\n        slider = QtWidgets.QSlider(QtCore.Qt.Orientation.Horizontal)\n        slider.setSingleStep(step_size)\n        slider.setRange(min_v, max_v)\n        slider.setValue(value)\n        if fn != None: slider.valueChanged.connect(fn)\n        add_to.addWidget(slider)\n        return slider\n\n\n    @staticmethod\n    def make_combo(add_to, items, fn=None):\n        combo = QtWidgets.QComboBox()\n        for item in items: combo.addItem(item)\n        if fn != None: combo.currentIndexChanged.connect(fn)\n        add_to.addWidget(combo)\n        return combo\n\n\n    @staticmethod\n    def list(add_to, items, fn=None):\n        qlist = QtWidgets.QListWidget()\n        for item in items: qlist.addItem(item)\n        if fn != None: qlist.itemSelectionChanged.connect(fn)\n        add_to.addWidget(qlist)    \n        return qlist\n\n\nclass UIHelper:\n\n\n    @staticmethod\n    def set_active_index(list_object, index):\n        return list_object.setCurrentRow(index)\n\n\n    @staticmethod\n    def current_item_not_none(list_object):\n        return list_object.currentItem() is not None\n\n\n    @staticmethod\n    def read_active_item_from_list(list_object):\n        return list_object.currentItem().data(32)\n\n\n    @staticmethod\n    def read_items_from_list(list_object):\n        return [list_object.item(i).data(32) for i in range(list_object.count())]\n\n\n    @staticmethod\n    def pop_active_item_from_list(list_object):\n        return list_object.takeItem(list_object.currentRow()).data(32)\n\n\n    @staticmethod\n    def add_item_to_list(name, item, list_object):\n        list_item = QtWidgets.QListWidgetItem()\n        list_item.setText(name)\n        list_item.setData(32, item)\n        list_object.addItem(list_item)\n        list_object.setCurrentItem(list_item)\n\n\n    @staticmethod\n    def add_items_to_list(names, items, list_object):\n        for (name, item) in zip(names, items):\n            UIHelper.add_item_to_list(name, item, list_object)\n\n\n    @staticmethod\n    def clear_list(list_object):\n        list_object.clear()\n\n\nclass DrawingBuilder:\n\n\n    @staticmethod\n    def makeRGBColor(r, g, b):\n        return QtGui.QColor.fromRgb(r, g, b)\n\n\n    @staticmethod\n    def makeHSLColor(h, s, v):\n        return QtGui.QColor.fromHsvF(h / 360.0, s / 100.0, v / 100.0)\n\n\n    @staticmethod\n    def red():\n        return DrawingBuilder.makeHSLColor(6, 75, 70)\n    \n    @staticmethod\n    def blue():\n        return DrawingBuilder.makeHSLColor(182, 29, 81)\n    \n    @staticmethod\n    def white():\n        return DrawingBuilder.makeHSLColor(233, 4, 91)\n\n\n    @staticmethod\n    def create_background_color_fn(r, g, b):\n        def fn(parent, painter):\n            w, h = parent.rect().width(), parent.rect().height()\n            brush = QBrush(QtGui.QColor.fromRgb(r, g, b))\n            pen = QPen(QtGui.QColor.fromRgb(0, 0, 0, a=0))\n            painter.setBrush(brush)\n            painter.setPen(pen)\n            painter.drawRect(0, 0, w, h)\n        return fn\n\n\n    @staticmethod\n    def create_points_fn(points, color, size=1):\n        def fn(parent, painter):\n            w, h = parent.rect().width(), parent.rect().height()\n            pen = QPen(color, size)\n            painter.setPen(pen)\n            for (a, b) in zip(points[:-1], points[1:]):\n                painter.drawLine(a[0] * w, h - a[1] * h, b[0] * w, h - b[1] * h)\n        return fn\n    \n    @staticmethod\n    def create_horizontal_line_based_on_attribute_fn(get_attr_fn, get_attr_range_fn, color, size=1):\n\n\n        def fn(parent, painter):\n            w, h = parent.rect().width(), parent.rect().height()\n            pen = QPen(color, size)\n            pen.setStyle(QtCore.Qt.DashLine)\n            painter.setPen(pen)    \n            min_v, max_v = get_attr_range_fn()\n            y = h * (1 - ((get_attr_fn() - min_v) / (max_v - min_v)))\n            painter.drawLine(0, y, w, y)\n        return fn\n\n\n    @staticmethod\n    def create_vertical_line_based_on_attribute_fn(get_attr_fn, get_attr_range_fn, color, size=1):\n        def fn(parent, painter):\n            w, h = parent.rect().width(), parent.rect().height()\n            pen = QPen(color, size)\n            pen.setStyle(QtCore.Qt.DashLine)\n            painter.setPen(pen)\n            min_v, max_v = get_attr_range_fn()\n            x = w * (get_attr_fn() - min_v) / (max_v - min_v)\n            painter.drawLine(x, 0, x, h)\n        return fn\n\n\n    @staticmethod\n    def make(add_to, parent, size):\n\n\n        class DrawingWidget(QtWidgets.QWidget):\n\n\n            def __init__(self):\n                super(DrawingWidget, self).__init__()\n                self.setParent(parent)\n                self.resize(size[0], size[1])\n                self.enabledState = False\n                self.enabled = True\n\n\n                self.disabled_fn = DrawingBuilder.create_background_color_fn(50, 50, 50)\n                self.drawing_fns = [DrawingBuilder.create_background_color_fn(30, 30, 30)]\n\n\n                vbox = UIBuilder.vertical_box(parent=self)\n                UIBuilder.make_spacer(vbox, size)\n\n\n            def reset_drawing_fns(self):\n                self.drawing_fns = [DrawingBuilder.create_background_color_fn(30, 30, 30)]\n                self.enabledState = False\n\n\n            def add_drawing_fn(self, fn):\n                self.drawing_fns.append(fn)\n\n\n            def activate(self):\n                self.enabledState = True\n\n\n            def paintEvent(self, e):\n                painter = QPainter(self)\n                if not self.enabledState:\n                    self.disabled_fn(self, painter)\n                else:\n                    for fn in self.drawing_fns:\n                        fn(self, painter)\n\n\n        painter = DrawingWidget()\n        add_to.addWidget(painter)\n        return painter\n\n\nclass SavedAnimation:\n\n\n    def __init__(self, objects, start, end):\n        self.objects = objects\n        self.start = start\n        self.end = end\n\n\n        self.save()\n\n\n    def save(self):\n        self.animation = {}\n        for object in self.objects:\n            data = {}\n            connections = cmds.listConnections(object)\n            if connections is None:\n                return\n\n\n            curves = [x for x in connections if \"animCurve\" in cmds.nodeType(x)]\n            for curve in curves:\n                \n                times = cmds.keyframe(curve, query=True, time=(self.start, self.end))\n                if times is None:\n                    data[curve] = None\n                else:                    \n                    values = [cmds.keyframe(curve, time=(t, t), eval=True, query=True)[0] for t in times]\n                    inWeights = [cmds.keyTangent(curve, query=True, time=(t, t), inWeight=True)[0] for t in times]\n                    inAngles = [cmds.keyTangent(curve, query=True, time=(t, t), inAngle=True)[0] for t in times]\n                    outWeights = [cmds.keyTangent(curve, query=True, time=(t, t), outWeight=True)[0] for t in times]\n                    outAngles = [cmds.keyTangent(curve, query=True, time=(t, t), outAngle=True)[0] for t in times]\n\n\n                    data[curve] = {\n                        \"keys\" : list(zip(times, values)),\n                        \"ins\" : list(zip(inWeights, inAngles)),\n                        \"outs\" : list(zip(outWeights, outAngles))\n                    }\n\n\n            self.animation[object] = data\n\n\n    def revert(self):\n        for object in self.animation.keys():\n            data = self.animation[object]\n            curves = data.keys()\n            for curve in curves:\n\n\n                # Curve contained no keyframe data when saved, so cut whatever is there now\n                if data[curve] == None:\n                    cmds.cutKey(curve, time=(self.start, self.end))\n                    return\n\n\n                keys = data[curve][\"keys\"]\n                times = [k[0] for k in keys]\n                ins = data[curve][\"ins\"]\n                outs = data[curve][\"outs\"]\n                curve_data = list(zip(keys, ins, outs))\n\n\n                start = times[0]\n                end = times[-1]\n\n\n                # Remove all frames in section\n                for (s, e) in zip(times[:-1], times[1:]):\n                    if e - s > 1:\n                        cmds.cutKey(curve, time=(s + 1, e - 1))\n\n\n                # Rebuild the animation\n                for ((time, value), (inWeight, inAngle), (outWeight, outAngle)) in curve_data:\n                    cmds.setKeyframe(curve, value=value, time=time)\n                    cmds.keyTangent(curve, edit=True, time=(time, time), inWeight=inWeight, inAngle=inAngle, absolute=True)\n                    cmds.keyTangent(curve, edit=True, time=(time, time), outWeight=outWeight, outAngle=outAngle, absolute=True)\n\n\nclass SalientPoses:\n\n\n    @staticmethod\n    def get_dimensions():\n        dimensions = [\"time\"]\n        for object in cmds.ls(selection=True):\n            dimensions += [\"%s.%s\" % (object, attr) for attr in [\"tx\", \"ty\", \"tz\"]]\n        return dimensions\n    \n    @staticmethod\n    def get_animation_data(start, end):\n        sel = cmds.ls(selection=True)\n\n\n        # Attach proxies\n        proxies = []\n        for object in sel:\n            proxy = cmds.spaceLocator()[0]\n            cmds.parentConstraint(object, proxy)\n            proxies.append(proxy)\n\n\n        # Get world-space position of proxies\n        anim_data = []\n        for i in range(start, end + 1):\n            anim_data += [float(i)]\n            for object in proxies:\n                anim_data += cmds.getAttr(\"%s.worldMatrix\" % object, time=i)[12:15]\n        \n        # Clean up\n        cmds.delete(proxies)\n        cmds.select(sel, replace=True)\n        return anim_data\n\n\ndef select_keyframes(cl_platform_ix, cl_device_ix, start, end, fixed_keyframes):\n    anim_data = SalientPoses.get_animation_data(start, end)\n    dimensions = SalientPoses.get_dimensions()\n\n\n    # Select\n    result = cmds.salientSelect(\n        cl_platform_ix, cl_device_ix,\n        start, end,\n        anim_data, dimensions, fixed_keyframes\n    )\n    \n    # Compile selections from result\n    selections = {}\n    for line in result.split(\"\\n\"):\n        if line != \"\":\n            errorString, selectionString = line.split(\"|\")\n            error = float(errorString)\n            selection = [int(v) for v in selectionString.split(\",\")]\n            n_keyframes = len(selection)\n            selections[n_keyframes] = { \"selection\" : selection, \"error\" : error }\n    return selections\n\n\ndef reduce_keyframes(selection):\n    start = selection[0]\n    end = selection[-1]\n\n\n    # Bake\n    objects = cmds.ls(selection=True)\n    cmds.bakeResults(objects, t=(start, end), sampleBy=1, minimizeRotation=True, preserveOutsideKeys=True)\n\n\n    # Reduce\n    cmds.salientReduce(start=start, finish=end, selection=selection)\n\n\ndef getMayaMainWindow():\n    mayaPtr = omui.MQtUtil.mainWindow()\n    return wrapInstance(long(mayaPtr), QtWidgets.QWidget)\n\n\nclass SalientPosesDialog(MayaQWidgetDockableMixin, QtWidgets.QWidget):\n\n\n    def __init__(self, parent=None):\n        super(SalientPosesDialog, self).__init__(parent)\n        self.my_parent = parent\n        \n        self.selections = {}\n        self.saved_animations = []\n\n\n        def init_ui(): \n            vbox = UIBuilder.vertical_box(parent=self)\n\n\n            # OpenCL device choice\n            listed_devices = [v for v in cmds.salientOpenCLInfo().split(\"\\n\") if v != \"\"]\n            hbox = UIBuilder.horizontal_box(add_to=vbox)\n            UIBuilder.label(hbox, \"OpenCL Device\")\n            self.opencl_device_combo = UIBuilder.make_combo(hbox, listed_devices)\n            \n            # Fixed keyframes text field\n            hbox = UIBuilder.horizontal_box(add_to=vbox)\n            UIBuilder.label(hbox, \"Fixed Keyframes\")\n            self.fixed_keyframes_edit = UIBuilder.line_edit(hbox, \"\")\n\n\n            # N keyframes text field\n            hbox = UIBuilder.horizontal_box(add_to=vbox)\n            UIBuilder.label(hbox, \"N Keyframes\")\n            self.n_keyframes_edit = UIBuilder.line_edit(hbox, str(3), self.set_n_keyframes_via_text)\n\n\n            # Error text field\n            hbox = UIBuilder.horizontal_box(add_to=vbox)\n            UIBuilder.label(hbox, \"Error\")\n            self.error_edit = UIBuilder.line_edit(hbox, \"%2.4f\" % -1)\n            self.error_edit.setEnabled(False)\n\n\n            # N keyframes slider\n            hbox = UIBuilder.horizontal_box(add_to=vbox)\n            start = int(cmds.playbackOptions(query=True, minTime=True))\n            end = int(cmds.playbackOptions(query=True, maxTime=True))\n            self.n_keyframes_slider = UIBuilder.slider(hbox, 3, end - start + 1, 1, 3, self.set_n_keyframes_via_slider)\n\n\n            # Error drawing\n            hbox = UIBuilder.horizontal_box(add_to=vbox)\n            self.painter = DrawingBuilder.make(hbox, self, (200, 200))\n\n\n            # Actions\n            hbox = UIBuilder.horizontal_box(add_to=vbox)\n            UIBuilder.label(hbox, \"Actions\")\n            UIBuilder.button(hbox, \"Evaluate\", fn=self.do_select)\n            UIBuilder.button(hbox, \"Reduce\", fn=self.do_reduce)\n            self.undo_button = UIBuilder.button(hbox, \"Undo (0)\", fn=self.revert_to_saved)\n\n\n        init_ui()\n        self.setWindowTitle('Salient Poses')\n\n\n    def save_animation(self, objects, start, end):\n        saved = SavedAnimation(objects, start, end)\n        self.saved_animations.append(saved)\n        self.undo_button.setText(\"Undo (%d)\" % len(self.saved_animations))\n\n\n    def revert_to_saved(self):\n        if len(self.saved_animations) > 0:\n            self.saved_animations.pop().revert()\n            self.undo_button.setText(\"Undo (%d)\" % len(self.saved_animations))\n        else:\n            cmds.error(\"No more animations left in undo history\")\n\n\n    def do_select(self):\n        opencl_device_info_str = self.opencl_device_combo.currentText()\n        cl_platform_ix_str, cl_device_ix_str = opencl_device_info_str.split(\" \")[0].split(\".\")\n        cl_platform_ix = int(cl_platform_ix_str)\n        cl_device_ix = int(cl_device_ix_str)\n\n\n        fixed_keyframes = []\n        fixed_keyframes_text = self.fixed_keyframes_edit.text().strip()\n        if fixed_keyframes_text != \"\":\n            fixed_keyframes = [int(v) for v in self.fixed_keyframes_edit.text().split(\",\")]\n\n\n        start = int(cmds.playbackOptions(query=True, minTime=True))\n        end = int(cmds.playbackOptions(query=True, maxTime=True))\n        self.selections = select_keyframes(cl_platform_ix, cl_device_ix, start, end, fixed_keyframes)\n\n\n        # Update slider bounds\n        self.n_keyframes_slider.setRange(*self.get_keyframe_range())\n\n\n        self.update_visualization()\n\n\n    def do_reduce(self):\n        objects = cmds.ls(selection=True)\n\n\n        # Convert all animation curves to independent euler\n        command_str = \"rotationInterpolation -c none\"\n        for object in objects:\n            command_str += \" %s.rotateX\" % object\n            command_str += \" %s.rotateY\" % object\n            command_str += \" %s.rotateZ\" % object\n        command_str += \";\"\n        mel.eval(command_str)\n\n\n        # Get configuration of selection\n        n_keyframes = self.n_keyframes_slider.value()\n        selection = self.selections[n_keyframes][\"selection\"]\n        start = selection[0]\n        end = selection[-1]\n\n\n        # Turn off ghosting first!\n        mel.eval(\"unGhostAll\")\n\n\n        # Save the current animation\n        self.save_animation(objects, start, end)\n\n\n        # Apply reduction\n        reduce_keyframes(selection)\n\n\n    def get_n_keyframes(self):\n        return self.n_keyframes_slider.value()\n\n\n    def get_error(self, n_keyframes=-1, normalized=True):\n        n = n_keyframes if n_keyframes != -1 else self.n_keyframes_slider.value()\n\n\n        if normalized:\n            min_n = min(self.selections.keys())\n            return self.selections[n][\"error\"] / self.selections[min_n][\"error\"]\n        else:\n            return self.selections[n][\"error\"]\n\n\n    def get_selection_of_n_keyframes(self, n_keyframes):\n        return self.selections[n_keyframes][\"selection\"]\n\n\n    def get_keyframe_range(self):\n        return min(self.selections.keys()), max(self.selections.keys())\n\n\n    def update_visualization(self):\n        \n        # Get data for error graph\n        n_keyframes = self.n_keyframes_slider.value()\n        self.error_edit.setText(\"%2.4f\" % self.get_error(n_keyframes, normalized=False))\n        min_keyframes, max_keyframes = self.get_keyframe_range()\n        xs = [float(n - min_keyframes) / float(max_keyframes - min_keyframes) for n in range(min_keyframes, max_keyframes + 1)]\n        ys = [self.get_error(n, normalized=True) for n in range(min_keyframes, max_keyframes + 1)]\n        points = list(zip(xs, ys))\n\n\n        # Submit data to make error graph\n        self.painter.reset_drawing_fns()\n        self.painter.add_drawing_fn(DrawingBuilder.create_points_fn(points, DrawingBuilder.red(), size=3))\n        self.painter.add_drawing_fn(DrawingBuilder.create_vertical_line_based_on_attribute_fn(self.get_n_keyframes, self.get_keyframe_range, DrawingBuilder.white()))\n        self.painter.add_drawing_fn(DrawingBuilder.create_horizontal_line_based_on_attribute_fn(self.get_error, lambda: (0, 1), DrawingBuilder.white()))\n        self.painter.activate()\n        self.repaint()\n\n\n        # Update ghosts\n        mel.eval(\"unGhostAll\")\n        frames = [int(v) for v in self.get_selection_of_n_keyframes(self.n_keyframes_slider.value())]\n        objects = cmds.ls(selection=True)\n        for object in objects:\n            obj_for_ghosting = object\n            obj_is_transform = cmds.objectType(object) == 'transform'\n            if obj_is_transform: # Change the object to the shape if this is a transform\n                obj_for_ghosting = cmds.listRelatives(object, shapes=True)[0]\n            cmds.setAttr(\"%s.ghosting\" % obj_for_ghosting, 1)\n            cmds.setAttr(\"%s.ghostingControl\" % obj_for_ghosting, 1)\n            cmds.setAttr(\"%s.ghostFrames\" % obj_for_ghosting, frames, type=\"Int32Array\")\n\n\n    def set_n_keyframes_via_text(self):\n        value = int(self.n_keyframes_edit.text())\n        self.n_keyframes_slider.setValue(value)\n        if len(self.selections) > 0:\n            self.error_edit.setText(\"%2.4f\" % self.get_error(self.n_keyframes_slider.value(), normalized=False))\n            self.update_visualization()\n            self.repaint()\n\n\n    def set_n_keyframes_via_slider(self, value):\n        self.n_keyframes_edit.setText(str(value))\n        if len(self.selections) > 0:\n            self.error_edit.setText(\"%2.4f\" % self.get_error(self.n_keyframes_slider.value(), normalized=False))\n            self.update_visualization()\n            self.repaint()\n\n\n_win = None\nif not \"SalientPosesMaya\" in cmds.pluginInfo(query=True, listPlugins=True):\n    cmds.error(\"SalientPosesMaya plugin is not loaded\")\n_win = SalientPosesDialog(parent=getMayaMainWindow())\n_win.show(dockable=True)" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;

} 
